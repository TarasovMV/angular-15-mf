---
sidebar_position: 5
---

# Распространенные проблемы и пути их решения

## Шаринг стилей

Чтобы расшарить глобальные стили между приложениями
(это может понадобится для запуска дочернего приложения, как самостоятельного),
можно использовать следующие варианты:

- добавить в `angular.json` (или `project.json` при использовании NX) shell-приложения ссылки на стили
  дочерних приложений

```json
{
    "targets": {
        "build": {
            "options": {
                "styles": [
                    "apps/shell/src/styles.less",
                    "apps/mfe1/src/styles.less",
                    "apps/mfe2/src/styles.less"
                ]
            }
        }
    }
}
```

- собрать стили в отдельный пакет и загружать зависимость через пакетный менеджер (npm)
- опубликовать стили на любой ресурс, который может отдавать статику (CDN) и подключать через index.html

## Шаринг ассетов

При использовании относительных ссылок на assets в дочернем приложении вы получите ошибку,
так как хост приложение будет уже располагаться по другому адресу
и относительный путь будет строиться именно от него. Для решения данной проблемы можно пойти 2мя путями:

- добавить в `angular.json` (или `project.json` при использовании NX) shell-приложения ссылки на ассеты
  дочерних приложений

```json
{
    "targets": {
        "build": {
            "options": {
                "assets": [
                    "apps/shell/src/assets",
                    "apps/mfe1/src/assets",
                    "apps/mfe2/src/assets"
                ]
            }
        }
    }
}
```

- использовать CDN, что так же уменьшит нагрузку на сервер приложения

## Локальная разработка

При большом количестве микрофронтендов или при использовании раздельных репозиториев возникает
проблема локального запуска приложения, для того, чтобы корректно запускать разрабатываемое приложение,
учитывая все зависимости shell приложения и наоборот можно применить следующие подходы:

- создать `mock` shell приложения и запускать его совместно с дочерним приложением, но тогда нужно позаботится
  об актуальности данного mock приложения и его постоянной поддержке
- на мой взгляд самым лучшим вариантом будет воспользоваться прокси сервером и прокидывать разрабатываемое
  приложение, вместо существующего на дев контуре, пример `utils/proxy-server.js`
  (P.S. `live reload` так же будет работать с прокси сервером)

## Передача данных между приложениями (шина данных)

Для передачи данных между приложениями можно использовать `root` сервисы из shared зависимостей, в данном
примере используется `RxStore` - сервис, который наследует `BehaviourSubject` для хранения и передачи данных.
Типизация вынесена в библиотеку models, которая не вызывает изменения в проектах **Nx**.

## Кеширование remote модулей

При использовании ссылок на `remoteEntry.js` файлы может возникнуть проблема их кеширования, что
не позволит пользователю увидеть новый функционал при обновлении приложения без сброса кэша, для
решения этой проблемы можно воспользоваться следующими подходами:

- добавить параметр в nginx, для принудительной отмены кеширования данного файла
- добавлять хэш к адресу расположения файла `remoteEntry.js`, например

```javascript
const hash = new Date().getTime();

loadRemoteModule({
    type: "module",
    remoteEntry: `https://example.com/remoteEntry.js${hash}`,
    exposedModule: './Module'
})
```

- лучшим вариантом будет использовать версионирование дочерних приложений и
  вместо хэша подставлять текущую версию:

```javascript
const app = 'mfe1';
const appVersion = manifest.getVersion(app);

loadRemoteModule({
    type: "module",
    remoteEntry: `https://example.com/remoteEntry.js?v=${appVersion}`,
    exposedModule: './Module'
})
```

## Использование разных инстансов root сервисов

При разработке на микрофронтендах вы можете столкнуться с тем, что приложения будут использовать разные
инстансы корневых сервисов приложения, такое может произойти в следующих случаях

- Несколько корневых областей. Root формируется при создании роутера, используя статичный метод forRoot,
  поэтому можно рассмотреть 2 варианта решения данной проблемы
    - в AppModule приложения использовать forChild, но тогда вы не сможете открыть приложение отдельно, без shell
    - создать вспомогательный модуль, который в свою очередь будет использовать forChild и экспортировать именно его
      (в данном примере используется именно такой подход)
- Используемая зависимость не является shared. Для того чтобы внутри каждого микрофронтенда использовался
  один инстанс singletone сервиса, необходимо, чтобы пакет или nx библиотека, в которой он находится, был помечен
  в файле конфигурации webpack как shared

## Запуск приложений с разными версиями angular

Для запуска приложений с разными версиями angular можно использовать web components.

Стоит отметить, что данное решение не является целевым и вызовет размеры с итоговым размером бандла, загружаемого
пользователем
